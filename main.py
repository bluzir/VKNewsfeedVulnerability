# -*- coding: utf-8 -*-

__author__ = 'Владислав'
import requests
from time import sleep
from datetime import datetime
from datetime import timedelta
from traceback import print_exc
import time
import sqlite3


with open("access_token.txt", "r") as myfile:
    token = myfile.read().replace('\n', '')  # http://vk.cc/2VN6UJ

publics = [28877622]  # список пабликов для парсинга
list_id = None  # для списков новостей


def get_my_id():
    url = 'https://api.vk.com/method/users.get'
    request = requests.get(url, params = {'access_token': token})
    decode = request.json()
    return decode['response'][0]['uid']


def get_posts_total_count():
    count = 0
    for item in publics:
        url = 'https://api.vk.com/method/wall.get'
        request = requests.get(url, params = {
            'access_token': token,
            'v': 5.24,
            'owner_id': "-"+str(item)
        })
        decode = request.json()
        count += int(decode['response']['count'])
    print(('в задаче %s постов') % (count))
    return count


def print_left_time(current, total, start_time):
    if current == 0:
        return 'хз'
    now = time.time()
    spend = now - start_time
    avr = spend/current

    left_time = (total-current)*avr
    left_time_str = str(timedelta(seconds=left_time) - timedelta(microseconds=timedelta(seconds=left_time).microseconds))
    spend_str = str(timedelta(seconds=spend) - timedelta(microseconds=timedelta(seconds=spend).microseconds))
    print (("времени осталось: %s, времени потрачено: %s") % (left_time_str, spend_str))


def create_table(pub, c):  # создаем таблицу с названием = айди паблика
    print ("Создаем таблицу: %s" % (str(pub)))
    c.execute("DROP TABLE IF EXISTS '%s'" % (str(pub)))
    c.execute('''CREATE TABLE IF NOT EXISTS '%s'(
          n integer PRIMARY KEY AUTOINCREMENT NOT NULL,
          post_id integer,
          person_id integer,
          signer_id integer,
          link text
          )''' % (str(pub)))
    print ("Таблица создана")


def create_work_list(target_id): # ета писал хохол
    global list_id
    print('создаем список')
    url = 'https://api.vk.com/method/newsfeed.saveList'
    par = {'title': 'title', 'source_ids': target_id, 'access_token': token}
    request = requests.get(url, params=par)
    request = request.json()
    if 'response' in request:
        list_id = request['response']
    else:
        if 'error' in request and 'error_code' in request['error'] and request['error']['error_code'] == 1170:
            print('у тебя слишком много списков, для работы нужно удалить хотя бы один. сделай это сам')
        else:
            print('неизвестная ошибка')
            print(request)
        exit()
    print ('Список с id:'+str(list_id)+' создан')
    pass


def get_post(x, count): # newsfeed_get для списка новостей
    url = 'https://api.vk.com/method/newsfeed.get'
    par = {'access_token': token,
           'count': count,
           'filters': 'post',
           'v': 5.24,
           'start_from': x,
           'source_ids': 'list'+str(list_id) }
    request = requests.get(url, params = par)
    decode = request.json()
    post = decode['response']
    # print(post)
    return post


def get_ids(post, my_id):  # получаем список айди для поста
    profiles = post['profiles']
    ids = []
    for item in profiles:
        id = item['id']
        if id != my_id:
            id = str(id)
            ids.append(id)
    print (ids)
    return ids


def get_link(post):  # получаем ссылку на пост
    content = post['items']
    link = ''
    for item in content:
        source = str(item['source_id'])
        post_id = str(item['post_id'])
        text = item['text']
        date = str(datetime.fromtimestamp(item['date']))
        link = "http://vk.com/wall%s_%s" % (source, post_id)
        print (link)
    return link


def get_id(post):  # так легче читать
    content = post['items']
    post_id = 0
    for item in content:
        post_id = str(item['post_id'])
    return post_id


def get_signer_id(post):
    content = post['items'][0]
    if 'signer_id' in content:
        signer_id = content['signer_id']
    else:
        signer_id = 0
    return signer_id


def get_next(post):  # получаем параметр next_from для следующего поста
    next = post['next_from']
    print (next)
    return next


def has_next(post):
    return 'next_from' in post


def delete_work_list():  # удаляем список новостей после парсинга
    global list_id
    url = 'https://api.vk.com/method/newsfeed.deleteList'
    par = {'list_id': list_id, 'access_token': token}
    request = requests.get(url, params=par)
    print('список с id '+str(list_id)+' удалено')
    pass


def get_result():
    my_id = get_my_id()
    progress = 0
    total = get_posts_total_count()

    for public_id in publics:
        conn = sqlite3.connect(str(public_id)+".db", timeout=10)
        c = conn.cursor()
        c.execute('PRAGMA journal_mode=TRUNCATE;')
        print ("Начинаем парсинг")
        while True:
            try:
                create_work_list(-public_id)
                create_table(public_id, c)
                start = time.time()  # time start here
                post = get_post(0, 1)
                ids = get_ids(post, my_id)
                link = get_link(post)
                signer_id = get_signer_id(post)
                for item in ids:
                    c.execute("INSERT INTO '%s'(post_id, person_id, signer_id, link) VALUES  (%s, %s, %s, '%s')" % (public_id, get_id(post), item, signer_id, link))
                nextpost = get_next(post)
                if not nextpost:
                    post = get_post(0, 2)
                    nextpost = get_next(post)
                sleep(1)
                progress += 1
                print_left_time(progress, total, start)
                conn.commit()
                break
            except sqlite3.Error:
                print_exc()
                sleep(1)
                # noinspection PyBroadException
                try:
                    conn.rollback()
                except:
                    pass
                sleep(3)
                conn = sqlite3.connect(str(public_id)+".db", timeout=10)
                c = conn.cursor()
                c.execute('PRAGMA journal_mode=TRUNCATE;')
                delete_work_list()
                sleep(1)
            except:
                sleep(1)
                conn.rollback()
                delete_work_list()
                print_exc()
                sleep(1)
                raise
            pass  # try
        pass  # iterative

        try:
            older = post
            while has_next(post):  # начало нужно для того, чтобы запустить цикл, иначе не получить некст_фром
                older = post
                try:
                    post = get_post(nextpost, 1)
                    ids = get_ids(post, my_id)
                    link = get_link(post)
                    signer_id = get_signer_id(post)
                    for item in ids:
                        c.execute("INSERT INTO '%s' (post_id, person_id, signer_id, link) VALUES (%s, %s, %s, '%s')" % (public_id, get_id(post), item, signer_id, link))
                    nextpost = get_next(post)
                    if not nextpost:
                        post = get_post(0, 2)
                        nextpost = get_next(post)
                    sleep(1)
                    progress += 1
                    print_left_time(progress, total, start)
                    conn.commit()
                except sqlite3.Error:
                    print_exc()
                    sleep(1)
                    # noinspection PyBroadException
                    try:
                        conn.rollback()
                    except:
                        pass
                    sleep(3)
                    conn = sqlite3.connect(str(public_id)+".db", timeout=10)
                    c = conn.cursor()
                    c.execute('PRAGMA journal_mode=TRUNCATE;')
                    post = older
                    continue
                pass  # try
            pass  # iteration
        finally:
            delete_work_list()
            conn.close()
    print ("Парсинг окончен")


get_result()
exit()
