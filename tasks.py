from __future__ import absolute_import
from celery import shared_task, app
from newsfeed.models import Friend, Newsfeed, Post, Attachment, Task
from django.contrib.auth.models import User
import datetime
import time
import requests
import pytz
from django.conf import settings
import os
import sys
import json


@shared_task
def get_friendlist(uid, token):
    user = User.objects.get(socialaccount__uid=uid)
    url = 'https://api.vk.com/method/friends.get'
    par = {'access_token': token, 'fields': ['first_name', 'last_name', 'photo_100'], 'v': 10}
    r = requests.get(url, params=par)
    friendlist = r.json()['response']
    for friend in friendlist['items']:
        Friend.objects.get_or_create(user=user, uid=friend['id'], first_name=friend['first_name'],
                                     second_name=friend['last_name'], photo=friend['photo_100'])
    return friendlist


def get_interval(year):
    years = 2015-float(year)
    #TODO: часовые пояса
    start = datetime.datetime.now() - datetime.timedelta(days=years*365)
    end = start + datetime.timedelta(days=1)
    start_format =start.strftime('%d/%m/%Y')
    end_format = end.strftime('%d/%m/%Y')
    start_timestamp = time.mktime(datetime.datetime.strptime(start_format, '%d/%m/%Y').timetuple())
    end_timestamp = time.mktime(datetime.datetime.strptime(end_format, '%d/%m/%Y').timetuple())
    start = int((str(start_timestamp)[:-2]))
    end = int((str(end_timestamp)[:-2]))
    return {'start': start, 'end': end}


class Request:
    url = "https://api.vk.com/method/"

    def __init__(self, method, params = {}):
        self.method = method
        self.params = params

    def make_request(self):
        try:
            r = requests.get(self.url+self.method, params=self.params, timeout=3)
            req = r.json()
            response = req['response']
        except KeyError:
            print(req['error'])
            return False
        except:
            time.sleep(1)
            r = requests.get(self.url+self.method, params=self.params, timeout=3)
            req = r.json()
            response = req['response']
        return response



class Date:

    def __init__(self, year):
        self.year = year
        self.start = None
        self.end = None


    def get_interval(self):
        #TODO: проверять дату
        years = 2015-int(self.year)
        start = datetime.datetime.now() - datetime.timedelta(days=years*365)
        end = start + datetime.timedelta(days=1)
        start_format  = start.strftime('%d/%m/%Y')
        end_format  = end.strftime('%d/%m/%Y')
        start_timestamp = time.mktime(datetime.datetime.strptime(start_format, '%d/%m/%Y').timetuple())
        end_timestamp = time.mktime(datetime.datetime.strptime(end_format, '%d/%m/%Y').timetuple())
        self.start = int((str(start_timestamp)[:-2]))
        self.end = int((str(end_timestamp)[:-2]))


getPost = Request("wall.get")
getPost.params['v'] = '10'
getPost.params['filter'] = 'owner'
getPost.params['count'] = 100


def check_oldfag(response, interval):
    count = response['count']
    if count>0:
        getPost.params['offset'] = int(count)-1
        resp = getPost.make_request()
        if resp['items'][0]['date'] < int(interval.end):
            time.sleep(0.5)
            return True


def check_date(item, interval):
    date = item['date']
    if interval.start < date < interval.end:
        return True


def parse_newsfeed(token, friend, interval, newsfeed):
    getPost.params['owner_id'] = friend.uid
    getPost.params['access_token'] = token
    resp = getPost.make_request()
    time.sleep(0.5)
    if resp:
        count = int(resp['count'])
        if count > 100:
            if check_oldfag(resp, interval):
                offset = count//2
                step = offset//2
                while step > 100:
                    getPost.params['offset'] = offset
                    resp = getPost.make_request()
                    if resp:
                        date = int(resp['items'][0]['date'])
                        time.sleep(5)
                        if date < interval.end:
                            offset -= step
                        else:
                            offset += step
                        step //= 2
                        time.sleep(0.5)
                        getPost.params['offset'] = offset
    else:
        return False
    for item in resp['items']:
        if check_date(item, interval):
            try:
                text = item['text']
            except:
                text = ''
            link = 'https://vk.com/wall%s_%s' % (friend.uid, item['id'])
            date = item['date']
            local_tz = pytz.timezone("Europe/Moscow")
            utc_dt = datetime.datetime.utcfromtimestamp(date).replace(tzinfo=pytz.utc)
            dt = local_tz.normalize(utc_dt.astimezone(local_tz))
            post, created = Post.objects.get_or_create(newsfeed=newsfeed, friend=friend,
                                              link=link, datetime=dt, text=text)
            if created:
                print('created')
            try:
                for att in item['attachments']:
                    type = att['type']
                    if type == 'photo':
                        photo = att['photo']
                        link = photo['photo_604']
                        attachment, created = Attachment.objects.get_or_create(post=post, type=type, link=link)
                    elif type == 'audio':
                        audio = att['audio']
                        name = '%s -- %s' % (audio['artist'], audio['title'])
                        attachment, created = Attachment.objects.get_or_create(post=post, type=type, name=name)
            except:
                pass



def progress(total, current, per, uid):
    BASE_DIR = os.path.abspath(os.path.dirname(__file__))
    dir = os.path.join(BASE_DIR, 'static', 'newsfeed', uid+'.json')
    js = {'total': total, 'current': current, 'percent': per}
    with open(dir, 'w+') as fp:
        json.dump(js, fp)


@shared_task()
def collect_newsfeed(year, id):
    interval = get_interval(year)
    print(interval['start'], interval['end'])
    user = User.objects.get(id=id)
    newsfeed, created = Newsfeed.objects.get_or_create(user=user, year=year)
    uid = collect_newsfeed.request.id
    task = Task.objects.get_or_create(newsfeed=newsfeed, uid=uid)
    print(collect_newsfeed.request.id)
    if created == True:
        print('created')
    friends = user.friend_set.all()
    token = user.socialaccount_set.all()[0].socialtoken_set.all()[0].token
    interval = Date(year)
    interval.get_interval()
    current = 0
    total = len(friends)
    percent = total/100
    for friend in friends:
        current += 1
        parse_newsfeed(token, friend, interval, newsfeed)
        per = int(current//percent)
        progress(total, current, per, uid)
    progress(total, current, 100, uid)
    newsfeed.ready = True
    newsfeed.save()


